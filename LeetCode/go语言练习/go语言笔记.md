## 短变量声明
- 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。
函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。
## 基本类型
Go 的基本类型有
> bool  
string  
int  int8  int16  int32  int64  
uint uint8 uint16 uint32 uint64 uintptr  
byte // uint8 的别名  
rune // int32 的别名  
    // 表示一个 Unicode 码点  
float32 float64  
complex64 complex128   

- int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。
## 零值
没有明确初始值的变量声明会被赋予它们的 零值。
零值是：  
数值类型为 0，  
布尔类型为 false，  
字符串为 ""（空字符串）。
## 常量
常量的声明与变量类似，只不过是使用 const 关键字。  
常量可以是字符、字符串、布尔值或数值。  
常量不能用 := 语法声明。  
## 数组和切片
- 数组的长度不可变，切片可变。切片底层就是数组，使用相同底层数组的切片，底层数组一旦被改写，那么相应的值都会发生变化，
切片扩容之后会使用新的底层数组，与原来的不再相关联。
- 切片就像数组的引用
切片并不存储任何数据，它只是描述了底层数组中的一段。
更改切片的元素会修改其底层数组中对应的元素。
与它共享底层数组的切片都会观测到这些修改。
## nil 切片
切片的零值是 nil。
nil 切片的长度和容量为 0 且没有底层数组。
## 函数
- 一等公民，函数式编程，高阶函数-传入的参数是函数类型，返回的也是函数类型。
## 函数值
- 函数也是值。它们可以像其它值一样传递。
函数值可以用作函数的参数或返回值。
## 结构体
- 把类型当做字段嵌入到另一个结构体类型，就可以使用该嵌入字段的一切。这与继承是不同的，不能说“go 语言通过嵌入字段实现了继承”。
- 值方法和指针方法
    - 值方法是该方法所属类型值的副本，改变并不会对原值有影响。只包含值方法。
    - 指针方法是该方法所属类型值指针值的副本，对其指向值得修改一定会改变原值。既包含值方法，又包含指针方法。
## defer
- defer 语句会将函数推迟到外层函数返回之后执行。
推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
## defer 栈
- 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。
更多关于 defer 语句的信息，[请阅读此博文](https://blog.go-zh.org/defer-panic-and-recover)。
## 测试
- 对于功能测试函数来说，其名称必须以 Test 为前缀，并且参数列表中只应有一个 *testing.T 类型的参数声明。
- 对于性能测试函数来说，其名称必须以 Benchmark 为前缀，并且唯一参数的类型必须是 *testing.B 类型的。
- 对于示例测试函数来说，其名称必须以 Example 为前缀，但对函数的参数列表没有强制规定
## 条件变量与互斥锁
- 条件变量是基于互斥锁的一种同步工具，它必须有互斥锁的支撑才能发挥作用。条件变量可以协调那些想要访问共享资源的线程。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程
- 在 Go 语言中，我们需要用sync.NewCond函数来初始化一个sync.Cond类型的条件变量。sync.NewCond函数需要一个sync.Locker类型的参数值。*sync.Mutex类型的值以及*sync.RWMutex类型的值都可以满足这个要求。
- 另外，后者的RLocker方法可以返回这个值中的读锁，也同样可以作为sync.NewCond函数的参数值，如此就可以生成与读写锁中的读锁对应的条件变量了。条件变量的Wait方法需要在它基于的互斥锁保护下执行，否则就会引发不可恢复的 panic。
- 此外，我们最好使用for语句来检查共享资源的状态，并包裹对条件变量的Wait方法的调用。不要用if语句，因为它不能重复地执行“检查状态 - 等待通知 - 被唤醒”的这个流程。重复执行这个流程的原因是，一个“因为等待通知，而被阻塞”的 goroutine，可能会在共享资源的状态不满足其要求的情况下被唤醒。
- 条件变量的Signal方法只会唤醒一个因等待通知而被阻塞的 goroutine，而它的Broadcast方法却可以唤醒所有为此而等待的 goroutine。后者比前者的适应场景要多得多。这两个方法并不需要受到互斥锁的保护，我们也最好不要在解锁互斥锁之前调用它们
- 还有，条件变量的通知具有即时性。当通知被发送的时候，如果没有任何 goroutine 需要被唤醒，那么该通知就会立即失效
## 临时对象池
- 我们可以把临时对象池当作针对某种数据的缓存来用，临时对象池最主要的用途就在于此
- 方法：Put和Get。Put 用于在当前的池中存放临时对象，它接受一个interface{}类型的参数；而 Get 则被用于从当前的池中获取临时对象，它会返回一个interface{}类型的值
