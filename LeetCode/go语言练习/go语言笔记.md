## 短变量声明
- 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。
函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。
## 基本类型
Go 的基本类型有
> bool  
string  
int  int8  int16  int32  int64  
uint uint8 uint16 uint32 uint64 uintptr  
byte // uint8 的别名  
rune // int32 的别名  
    // 表示一个 Unicode 码点  
float32 float64  
complex64 complex128   

- int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。
## 零值
没有明确初始值的变量声明会被赋予它们的 零值。
零值是：  
数值类型为 0，  
布尔类型为 false，  
字符串为 ""（空字符串）。
## 常量
常量的声明与变量类似，只不过是使用 const 关键字。  
常量可以是字符、字符串、布尔值或数值。  
常量不能用 := 语法声明。  
## 数组和切片
- 数组的长度不可变，切片可变。切片底层就是数组，使用相同底层数组的切片，底层数组一旦被改写，那么相应的值都会发生变化，
切片扩容之后会使用新的底层数组，与原来的不再相关联。
- 切片就像数组的引用
切片并不存储任何数据，它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

与它共享底层数组的切片都会观测到这些修改。
## 函数
- 一等公民，函数式编程，高阶函数-传入的参数是函数类型，返回的也是函数类型。
## 结构体
- 把类型当做字段嵌入到另一个结构体类型，就可以使用该嵌入字段的一切。这与继承是不同的，不能说“go 语言通过嵌入字段实现了继承”。
- 值方法和指针方法
    - 值方法是该方法所属类型值的副本，改变并不会对原值有影响。只包含值方法。
    - 指针方法是该方法所属类型值指针值的副本，对其指向值得修改一定会改变原值。既包含值方法，又包含指针方法。
## defer
- defer 语句会将函数推迟到外层函数返回之后执行。
推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
## defer 栈
- 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。
更多关于 defer 语句的信息，[请阅读此博文](https://blog.go-zh.org/defer-panic-and-recover)。
